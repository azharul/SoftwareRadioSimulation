function [y,f] = lmseq(r,training_signal)training_threshold = 2000;H = length(training_signal);k = 1:H;n=16; f=zeros(n,1);             % initialize equalizer at 0mu=.003; delta=8;               % stepsize and delay delta%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The following code located the training signal using block processing, which we% consider "cheaping out".  Instead, when the correlation between the signal and % training signal exceeds a certain threshold, we figure we have located the % training signal.% %xc = xcorr(r,training_signal);%[dummy,index] = max(abs(xc));%offset = length(r) - length(training_signal);%figure; %plot(1:length(xc(offset:end)),xc(offset:end)); ylabel('xcorr(received,training_signal)');%tindex = index-offset-H%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%figure;plot(xcorr(r,training_signal));for k = 1:length(r)-H    if abs(r(k:k+H-1)*training_signal') > training_threshold        break    endendif r(k:k+H-1)*training_signal' < 0    r = -r;endktindex = k-1R = length(r);training = r(tindex:tindex+H-1);errs = zeros(1,delta+H);filler = zeros(1,H);for i=tindex+delta:tindex+delta+H-1                 % iterate   rr=r(i:-1:i-n+1)';                                % vector of received signal  e=training_signal(i-tindex-delta+1)-f'*rr;        % calculate error  errs(i-tindex-delta+1) = e;  f=f+mu*e*rr;                                      % update equalizer coefficients  filler(i-tindex-delta+1) = f'*rr;enddata = filter(f,1,r(tindex+H+1:end));figure;subplot(3,1,1),plot(training,'r');ylabel('training signal');subplot(3,1,2),stem(f);ylabel('equalizer taps');subplot(3,1,3),plot(errs.^2);ylabel('squared error'); xlabel('iterations');f = f/norm(f);y = [r(1:tindex) filler data];